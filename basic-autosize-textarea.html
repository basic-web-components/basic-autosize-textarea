<!--
/**
 * A text area that makes itself big enough to show its content.
 * 
 * This works by copying the text to an invisible element which will automatically
 * grow in size; the expanding copy will expand the container, which in turn
 * stretch the text area.
 *
 * NOTE: This component can currently flash on polyfilled browsers, especially
 * desktop and mobile Safari.
 *
 * @class basic-autosize-textarea

TODO
Use extraSpace to measure line height, remove extraLine.
Autosize when value is changed programmatically
Absorb textContent on ready/attached
Remove basic-element inheritance

 */
-->

<link rel="import" href="../basic-element/basic-element.html">

<polymer-element name="basic-autosize-textarea" extends="basic-element" attributes="minimumRows placeholder value">

<!--
The template uses a pre element to hold the copied text in order to
automatically convert breaks, etc.

This pre contains an extraSpace element that ensures that, even if the last
line of the text box is blank, there will be something in the line that forces
the text copy to grow by a line. This extra space is a thin space, to reduce the
amount by which the text copy will prematurely grow.
-->

<template>

  <style>
  :host {
    display: block;
  }

  #autoSizeContainer {
    position: relative;
  }

  /*
   * Ensure both the text area and copy end up with the element's own font
   * metrics, so that text will lay out the same in both of them.
   */
  #textBox,
  #copyContainer {
    -moz-box-sizing: border-box;
    box-sizing: border-box;
    font-family: inherit;
    font-size: inherit;
    font-style: inherit;
    font-weight: inherit;
    line-height: inherit;
    margin: 0;
  }

  #textBox {
    height: 100%;
    /*left: 100px;*/
    overflow: hidden;
    position: absolute;
    resize: none;
    top: 0;
    width: 100%;
  }

  #copyContainer {
    visibility: hidden;
    white-space: pre-wrap; /* So lines wrap */
  }

  #sampleLine {
    position: absolute;
    visibility: hidden;
  }
  </style>

  <div id="autoSizeContainer">
    <textarea id="textBox" on-keypress="{{_keypress}}" placeholder="{{placeholder}}" spellcheck="{{spellcheck}}" value="{{value}}"></textarea>
    <pre id="copyContainer"><span id="textCopy"></span><span id="extraSpace">&thinsp;</span></pre>
    <div id="sampleLine">&nbsp;</div>
  </div>

</template>

<script>
Polymer( "basic-autosize-textarea", {

  /**
   * Resize the element such that the text box can exactly contain its content.
   * By default, this method is invoked whenever the text content changes.
   *
   * @method autoSize
   */
  autoSize: function() {
    // We resize by copying the text box contents to the element itself; the
    // text will then appear (via <content>) inside the invisible <pre>. If
    // we've set things up correctly, this new content should take up the same
    // amount of room as the same text in the text box. Updating the element's
    // content adjusts the element's size, which in turn will make the text box
    // the correct height.
    this.$.textCopy.textContent = this._escapeHtml( this.$.textBox.value );
  },

  attached: function() {

    // For auto-sizing to work, we need the text copy to have the same border,
    // padding, and other relevant characteristics as the original text area.
    // Since those aspects are affected by CSS, we have to wait until the
    // element is in the document before we can update the text copy.
    var textBoxStyle = getComputedStyle( this.$.textBox );
    var copyContainerStyle = this.$.copyContainer.style;
    copyContainerStyle.borderBottomStyle  = textBoxStyle.borderBottomStyle;
    copyContainerStyle.borderBottomWidth  = textBoxStyle.borderBottomWidth;
    copyContainerStyle.borderLeftStyle    = textBoxStyle.borderLeftStyle;
    copyContainerStyle.borderLeftWidth    = textBoxStyle.borderLeftWidth;
    copyContainerStyle.borderRightStyle   = textBoxStyle.borderRightStyle;
    copyContainerStyle.borderRightWidth   = textBoxStyle.borderRightWidth;
    copyContainerStyle.borderTopStyle     = textBoxStyle.borderTopStyle;
    copyContainerStyle.borderTopWidth     = textBoxStyle.borderTopWidth;
    copyContainerStyle.paddingBottom      = textBoxStyle.paddingBottom;
    copyContainerStyle.paddingLeft        = textBoxStyle.paddingLeft;
    copyContainerStyle.paddingRight       = textBoxStyle.paddingRight;
    copyContainerStyle.paddingTop         = textBoxStyle.paddingTop;

    // TODO: On Mozilla, an item which is in the document but not yet visible
    // will report its padding as zero. Since we don't know the real padding,
    // we need to take a guess that it's the standard padding.
    // if (paddingBottom === "0px" && paddingLeft === "0px" && paddingRight === "0px" && paddingTop === "0px") {
    //   paddingBottom = "2px";
    //   paddingLeft = "2px";
    //   paddingRight = "2px";
    //   paddingTop = "2px";
    // }

    // Use the sampleLine member to gauge the expected height of a single line of
    // text. We can't use lineHeight, because that can be reported as "normal",
    // and we want to know the actual pixel height.
    this._lineHeight = this.$.sampleLine.clientHeight;

    // Now that we know the lineheight, we can hide the extra line.
    // this.$.sampleLine.style.display = "none";

    this._setMinimumHeight();
  },

  /**
   * Determines the minimum number of rows in the textarea. This is similar to
   * the rows attribute on a standard textarea, but because the textarea can
   * grow, is expressed as a minimum rather than a fixed number.
   *
   * @attribute minimumRows
   * @type integer
   * @default 1
   */
  minimumRows: 1,

  // BUG: Setting the minimumRows attribute after creation doesn't seem to
  // trigger this changed handler.
  minimumRowsChanged: function() {
    if ( this._lineHeight ) {
      this._setMinimumHeight();
    }
  },

  ready: function() {
    this.super();
    this.$.textBox.addEventListener( "change", function() {
      console.log( "change" );
      // this.autoSize();
      // Raise our own change event (since change events aren't automatically
      // retargetted).
      this.dispatchEvent( new CustomEvent( "change" ));
    }.bind( this ));

    // this.$.textBox.value = this._unescapeHtml( this.textContent );
  },

  get selectionEnd() {
    return this.$.textBox.selectionEnd;
  },
  set selectionEnd( value ) {
    this.$.textBox.selectionEnd = value;
  },

  get selectionStart() {
    return this.$.textBox.selectionStart;
  },
  set selectionStart( value ) {
    this.$.textBox.selectionStart = value;
  },

  valueChanged: function() {
    this.autoSize();
  },

  _escapeHtml: function( html ) {
    return html
     .replace( /&/g, "&amp;" )
     .replace( /</g, "&lt;" )
     .replace( />/g, "&gt;" )
     .replace( /"/g, "&quot;" )
     .replace( /'/g, "&#039;" );
  },

  // Setting the minimumRows attribute translates into setting the minimum
  // height on the text copy container.
  _setMinimumHeight: function() {
    var copyContainer = this.$.copyContainer;
    var outerHeight = copyContainer.getBoundingClientRect().height;
    var style = getComputedStyle( copyContainer );
    var paddingTop = parseFloat( style.paddingTop );
    var paddingBottom = parseFloat( style.paddingBottom );
    var innerHeight = copyContainer.clientHeight - paddingTop - paddingBottom;
    var bordersPlusPadding = outerHeight - innerHeight;
    var minHeight = ( this.minimumRows * this._lineHeight ) + bordersPlusPadding;
    copyContainer.style.minHeight = minHeight + "px";
  },

  _unescapeHtml: function( html ) {
    return html
      .replace( /&amp;/g, "&" )
      .replace( /&lt;/g, "<" )
      .replace( /&gt;/g, ">" )
      .replace( /&quot;/g, "\"" )
      .replace( /&#039;/g, "'" );
  }
});
</script>

</polymer-element>
